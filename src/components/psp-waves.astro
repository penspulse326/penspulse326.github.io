---
// PSP 波浪特效 - 模擬 PlayStation 3/PSP 的 XMB 波浪背景
// 使用 Three.js 實現流動的波浪線條
---

<div id="psp-waves-container"></div>

<style>
  #psp-waves-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;

    /* 初始背景色 */
    background: linear-gradient(to bottom, #00a8a5 0%, #0861c5 100%);
    z-index: 0;
  }

  #psp-waves-container canvas {
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';

  let isInitialized = false;

  function initWaves() {
    if (isInitialized) return;

    const container = document.getElementById('psp-waves-container') as HTMLDivElement;

    // 如果容器還沒準備好，使用 RAF 重試，直到找到容器為止
    if (!container) {
      requestAnimationFrame(initWaves);
      return;
    }

    isInitialized = true;

    // 配置參數
    const config = {
      yOffset: -500, // 垂直偏移 (負數代表往下移)
    };

    // 建立場景
    const scene = new THREE.Scene();

    // 透視相機
    const fov = 75;
    const aspect = container.offsetWidth / container.offsetHeight;
    const near = 1;
    const far = 10000;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    // 調整相機位置，使其看向波浪的側面/上方
    camera.position.set(0, 0, 1000);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({
      alpha: true,
      antialias: true,
    });
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // 創建波浪
    // 我們使用一群粒子或線條來模擬
    // 這裡使用 Mesh + PlaneGeometry 並且動態更新頂點來製作「絲帶」效果

    const waves: THREE.Mesh[] = [];

    // 定義每個波浪的參數
    const waveParams = [
      { color: 0xffffff, opacity: 0.15, z: 0, speed: 0.3, offset: 0, amplitude: 200 },
      { color: 0xffffff, opacity: 0.1, z: -100, speed: 0.9, offset: 200, amplitude: 150 },
      { color: 0xffffff, opacity: 0.05, z: -200, speed: 0.6, offset: 400, amplitude: 100 },
    ];

    // 螢幕寬度對應的 3D 寬度計算
    const planeWidth = 12000;
    const planeSegments = 50; // 配合寬度增加分段數以保持平滑

    waveParams.forEach((param) => {
      // 每個波浪是一條帶子，所以用 PlaneGeometry
      const geometry = new THREE.PlaneGeometry(planeWidth, 1200, planeSegments, 1);

      const material = new THREE.MeshBasicMaterial({
        color: param.color,
        transparent: true,
        opacity: param.opacity,
        side: THREE.DoubleSide,
        depthWrite: false, // 避免遮擋
        blending: THREE.AdditiveBlending, // 發光效果
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.z = param.z;
      mesh.position.y = config.yOffset; // 應用垂直偏移

      // 儲存自定義數據到 userData
      mesh.userData = {
        speed: param.speed,
        offset: param.offset,
        baseVertices: [], // 儲存原始頂點位置
        amplitude: param.amplitude,
      };

      // 備份原始頂點
      const positions = geometry.attributes.position.array;
      for (let i = 0; i < positions.length; i++) {
        mesh.userData.baseVertices.push(positions[i]);
      }

      scene.add(mesh);
      waves.push(mesh);
    });

    function animate() {
      requestAnimationFrame(animate);

      // 使用時間戳記讓動畫速度一致
      const time = performance.now() * 0.001;

      // 更新波浪頂點
      waves.forEach((mesh) => {
        const positions = mesh.geometry.attributes.position.array;
        const count = mesh.geometry.attributes.position.count;
        const baseVertices = mesh.userData.baseVertices;

        for (let i = 0; i < count; i++) {
          const x = baseVertices[i * 3];
          const waveX = x * 0.0005 + mesh.userData.offset;
          const t = time * mesh.userData.speed;

          const movement =
            Math.sin(waveX + t) * mesh.userData.amplitude +
            Math.sin(waveX * 2 + t * 1.5) * (mesh.userData.amplitude * 0.5);

          positions[i * 3 + 1] = baseVertices[i * 3 + 1] + movement;
        }

        mesh.geometry.attributes.position.needsUpdate = true;
      });

      renderer.render(scene, camera);
    }

    // Resize 處理
    function handleResize() {
      if (!container) return;

      const width = container.offsetWidth;
      const height = container.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
    }

    window.addEventListener('resize', handleResize);
    animate();

    // 清理
    const cleanup = () => {
      window.removeEventListener('resize', handleResize);
      renderer.dispose();
      waves.forEach((w) => {
        w.geometry.dispose();
        (w.material as THREE.Material).dispose();
      });
    };

    window.addEventListener('beforeunload', cleanup);
  }

  // 嘗試在不同階段初始化，確保盡快執行
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    initWaves();
  } else {
    document.addEventListener('DOMContentLoaded', initWaves);
  }
</script>
