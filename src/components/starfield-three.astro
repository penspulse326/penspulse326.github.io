---
// 3D 方塊特效 - 使用 Three.js 創建 3D 方塊系統
---

<div id="starfield-three-container"></div>

<style>
  #starfield-three-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
  }

  #starfield-three-container canvas {
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';

  const container = document.getElementById('starfield-three-container') as HTMLDivElement;

  // 創建場景
  const scene = new THREE.Scene();

  // 創建正射影相機（減小 viewSize 讓方塊看起來更大）
  const width = container.offsetWidth;
  const height = container.offsetHeight;
  const aspect = width / height;
  const viewSize = 600; // 減小視圖大小讓方塊看起來更大
  const camera = new THREE.OrthographicCamera(-viewSize * aspect, viewSize * aspect, viewSize, -viewSize, 0.1, 2000);
  camera.position.z = 1000;

  // 創建渲染器
  const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
  renderer.setSize(container.offsetWidth, container.offsetHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  container.appendChild(renderer.domElement);

  // 創建方塊系統
  const boxCount = 150;
  const boxes: THREE.Mesh[] = [];
  const boxVelocities: Array<{ x: number; y: number; z: number }> = [];
  const boxRotations: Array<{ x: number; y: number; z: number }> = [];

  // 方塊每個面的顏色（以 0xf0f8ff 為基準，明度相差 5-15）
  // 基準顏色 RGB(240, 248, 255)
  const faceColors = [
    0xf5faff, // 面1: 稍微亮一點 RGB(245, 250, 255) +5
    0xf0f8ff, // 面2: 基準 RGB(240, 248, 255)
    0xebf3f8, // 面3: 稍微暗一點 RGB(235, 243, 248) -5
    0xe6eef5, // 面4: 更暗一點 RGB(230, 238, 245) -10
    0xe1e9f0, // 面5: 更暗 RGB(225, 233, 240) -15
    0xf5faff, // 面6: 稍微亮一點 RGB(245, 250, 255) +5
  ];

  // 初始化方塊
  for (let i = 0; i < boxCount; i++) {
    // 隨機大小（增大方塊讓它們看起來更大）
    const size = Math.random() * 30 + 30; // 40-100 之間

    // 創建方塊幾何體
    const geometry = new THREE.BoxGeometry(size, size, size);

    // 為每個面設置不同的顏色材質（使用 MeshBasicMaterial 不需要燈光）
    const materials = faceColors.map(
      (color) =>
        new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.7, // 降低透明度讓光線可以透過
          side: THREE.DoubleSide, // 雙面渲染
        }),
    );

    const box = new THREE.Mesh(geometry, materials);

    // 隨機位置（大幅擴大分布範圍，讓方塊更分散）
    box.position.x = (Math.random() - 0.5) * 4000; // 大幅增加 x 軸範圍
    box.position.y = (Math.random() - 0.5) * 3000; // 增加 y 軸範圍
    box.position.z = (Math.random() - 0.5) * 2000; // 增加深度範圍

    // 隨機初始旋轉
    box.rotation.x = Math.random() * Math.PI * 2;
    box.rotation.y = Math.random() * Math.PI * 2;
    box.rotation.z = Math.random() * Math.PI * 2;

    // 速度設定：所有方塊都向下移動（y 軸負方向），x 和 z 軸保留一些隨機性
    boxVelocities.push({
      x: (Math.random() - 0.5) * 0.2, // x 軸小幅隨機移動
      y: -(Math.random() * 1.0 + 0.8), // y 軸向下移動，速度 0.8-1.8（加快速度）
      z: (Math.random() - 0.5) * 0.2, // z 軸小幅隨機移動
    });

    // 隨機旋轉速度
    boxRotations.push({
      x: (Math.random() - 0.5) * 0.02,
      y: (Math.random() - 0.5) * 0.02,
      z: (Math.random() - 0.5) * 0.02,
    });

    boxes.push(box);
    scene.add(box);
  }

  // 動畫循環
  function animate() {
    requestAnimationFrame(animate);

    const time = Date.now() * 0.0005;

    // 更新每個方塊的位置和旋轉
    for (let i = 0; i < boxCount; i++) {
      const box = boxes[i];
      const velocity = boxVelocities[i];
      const rotation = boxRotations[i];

      // 更新位置
      box.position.x += velocity.x;
      box.position.y += velocity.y;
      box.position.z += velocity.z;

      // 更新旋轉
      box.rotation.x += rotation.x;
      box.rotation.y += rotation.y;
      box.rotation.z += rotation.z;

      // 邊界檢測
      // x 和 z 軸：從另一側重新出現
      if (Math.abs(box.position.x) > 2000) {
        box.position.x = -Math.sign(box.position.x) * 2000;
      }
      if (Math.abs(box.position.z) > 1000) {
        box.position.z = -Math.sign(box.position.z) * 1000;
      }
      // y 軸：向下移動，超出底部時從頂部重新出現
      if (box.position.y < -1500) {
        box.position.y = 1500; // 從頂部重新出現
      }
    }

    // 輕微旋轉相機以增加動態感
    camera.position.x = Math.sin(time * 0.1) * 50;
    camera.position.y = Math.cos(time * 0.15) * 50;
    camera.lookAt(scene.position);

    renderer.render(scene, camera);
  }

  // 處理視窗大小變化
  function handleResize() {
    const width = container.offsetWidth;
    const height = container.offsetHeight;
    const aspect = width / height;

    // 更新正射影相機的視圖大小
    camera.left = -viewSize * aspect;
    camera.right = viewSize * aspect;
    camera.top = viewSize;
    camera.bottom = -viewSize;
    camera.updateProjectionMatrix();

    renderer.setSize(width, height);
  }

  window.addEventListener('resize', handleResize);

  // 開始動畫
  animate();

  // 清理函數
  window.addEventListener('beforeunload', () => {
    window.removeEventListener('resize', handleResize);
    renderer.dispose();
    boxes.forEach((box) => {
      box.geometry.dispose();
      if (Array.isArray(box.material)) {
        box.material.forEach((mat: THREE.Material) => mat.dispose());
      } else {
        (box.material as THREE.Material).dispose();
      }
    });
  });
</script>
