---
// PSP 波浪特效 - 模擬 PlayStation 3/PSP 的 XMB 波浪背景
// 使用 Three.js 實現流動的波浪線條
---

<div id="psp-waves-container"></div>

<style>
  #psp-waves-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;

    /* 初始背景色 */
    background: linear-gradient(to bottom, #00a8a5 0%, #0861c5 100%);
    z-index: 0;
  }

  #psp-waves-container canvas {
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';

  let isInitialized = false;

  // 使用 LoadingManager 管理載入狀態
  const loadingManager = new THREE.LoadingManager();

  loadingManager.onLoad = () => {
    // 當所有資源載入完成時（目前這個組件沒有外部資源，但保持架構完整）
    // 我們在下一幀觸發事件，確保渲染器已經準備好第一幀
    requestAnimationFrame(() => {
      window.dispatchEvent(new CustomEvent('threejs-ready'));
    });
  };

  function initWaves() {
    if (isInitialized) return;

    const container = document.getElementById('psp-waves-container') as HTMLDivElement;

    if (!container) {
      requestAnimationFrame(initWaves);
      return;
    }

    isInitialized = true;

    // 配置參數
    const config = {
      yOffset: -500,
    };

    // 建立場景
    const scene = new THREE.Scene();

    // 透視相機
    const fov = 75;
    const aspect = container.offsetWidth / container.offsetHeight;
    const near = 1;
    const far = 10000;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.set(0, 0, 1000);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({
      alpha: true,
      antialias: true,
    });
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const waves: THREE.Mesh[] = [];

    const waveParams = [
      { color: 0xffffff, opacity: 0.15, z: 0, speed: 0.3, offset: 0, amplitude: 200 },
      { color: 0xffffff, opacity: 0.1, z: -100, speed: 0.9, offset: 200, amplitude: 150 },
      { color: 0xffffff, opacity: 0.05, z: -200, speed: 0.6, offset: 400, amplitude: 100 },
    ];

    const planeWidth = 12000;
    const planeSegments = 50;

    waveParams.forEach((param) => {
      const geometry = new THREE.PlaneGeometry(planeWidth, 1200, planeSegments, 1);
      const material = new THREE.MeshBasicMaterial({
        color: param.color,
        transparent: true,
        opacity: param.opacity,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.z = param.z;
      mesh.position.y = config.yOffset;

      mesh.userData = {
        speed: param.speed,
        offset: param.offset,
        baseVertices: [],
        amplitude: param.amplitude,
      };

      const positions = geometry.attributes.position.array;
      for (let i = 0; i < positions.length; i++) {
        mesh.userData.baseVertices.push(positions[i]);
      }

      scene.add(mesh);
      waves.push(mesh);
    });

    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now() * 0.001;

      waves.forEach((mesh) => {
        const positions = mesh.geometry.attributes.position.array;
        const count = mesh.geometry.attributes.position.count;
        const baseVertices = mesh.userData.baseVertices;

        for (let i = 0; i < count; i++) {
          const x = baseVertices[i * 3];
          const waveX = x * 0.0005 + mesh.userData.offset;
          const t = time * mesh.userData.speed;

          const movement =
            Math.sin(waveX + t) * mesh.userData.amplitude +
            Math.sin(waveX * 2 + t * 1.5) * (mesh.userData.amplitude * 0.5);

          positions[i * 3 + 1] = baseVertices[i * 3 + 1] + movement;
        }

        mesh.geometry.attributes.position.needsUpdate = true;
      });

      renderer.render(scene, camera);
    }

    // Resize 處理
    function handleResize() {
      if (!container) return;
      const width = container.offsetWidth;
      const height = container.offsetHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    window.addEventListener('resize', handleResize);
    animate();

    // 如果沒有資源要加載，手動觸發 LoadingManager 的 onLoad
    // 這樣即使目前沒用 TextureLoader 等，遮罩也能正確消失
    // 如果未來在這個組件加了 TextureLoader(loadingManager).load(...)，這行可以拿掉或改成檢查進度
    const checkLoading = () => {
      // 在這裡檢查是否還有待處裡的資源，通常 LoadingManager 會自動處理
      // 但因為我們目前實例化了它卻沒給它任務，它可能不會觸發 onLoad
      // 這裡我們模擬一個任務或者直接調用
      if (waves.length > 0) {
        // 確保波浪已經建立
        setTimeout(() => {
          loadingManager.onLoad();
        }, 300); // 給一點緩衝時間讓初次渲染更穩定
      }
    };
    checkLoading();

    // 清理
    const cleanup = () => {
      window.removeEventListener('resize', handleResize);
      renderer.dispose();
      waves.forEach((w) => {
        w.geometry.dispose();
        (w.material as THREE.Material).dispose();
      });
    };

    window.addEventListener('beforeunload', cleanup);
  }

  initWaves();
</script>
