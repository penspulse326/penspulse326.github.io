---
// 3D 方塊特效 - 使用 Three.js 創建 3D 方塊系統
---

<div id="starfield-three-container"></div>

<style>
  #starfield-three-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;

    /* 初始背景色,避免白屏 */
    background: linear-gradient(to bottom, #00a8a5 0%, #0861c5 100%);
  }

  #starfield-three-container canvas {
    display: block;
  }
</style>

<script>
  // 使用動態導入來延遲載入 Three.js
  let isInitialized = false;

  // 使用 IntersectionObserver 來檢測元件是否進入視窗
  const container = document.getElementById('starfield-three-container') as HTMLDivElement;

  // 延遲初始化函數
  async function initStarfield() {
    if (isInitialized) return;
    isInitialized = true;

    // 動態導入 Three.js
    const THREE = await import('three');

    // ========== 配置參數 ==========
    // 可以在這裡調整所有動畫相關的參數
    const config = {
      // 平面落下速度設定
      boxFallSpeed: {
        min: 0.8, // 最小落下速度
        max: 1.8, // 最大落下速度
      },
      // 平面水平移動速度（x 和 z 軸）
      boxHorizontalSpeed: 0.2, // x 和 z 軸的隨機移動範圍
      // 平面旋轉速度
      boxRotationSpeed: 0.02, // 旋轉速度的隨機範圍

      // 漸層變化速度
      gradientCycleSpeed: 0.0003, // 漸層循環速度（數值越大變化越快）
      // 漸層底部顏色領先百分比（形成向下流動效果）
      gradientBottomOffset: 0.3, // 0-1 之間，數值越大底部顏色領先越多
    };

    // 背景漸層顏色循環（定義幾個顏色點來創建平滑的循環效果）
    // 從 #00a8a5 (青綠色) 到 #0861c5 (藍色) 再到中間色，形成循環
    const gradientColors = [
      { r: 0, g: 168, b: 165 }, // #00a8a5
      { r: 8, g: 97, b: 197 }, // #0861c5
      { r: 4, g: 132, b: 181 }, // 中間色 #0484b5
      { r: 0, g: 168, b: 165 }, // 回到 #00a8a5 形成循環
    ];

    // 將 RGB 轉換為十六進位顏色字串
    function rgbToHex(r: number, g: number, b: number): string {
      return `#${[r, g, b].map((x) => x.toString(16).padStart(2, '0')).join('')}`;
    }

    // 線性插值函數
    function lerp(start: number, end: number, t: number): number {
      return start + (end - start) * t;
    }

    // 根據時間獲取漸層顏色
    function getGradientColors(time: number): { top: string; bottom: string } {
      // 計算循環進度（0 到 1），使用配置的漸層速度
      const baseProgress = (time * config.gradientCycleSpeed) % 1;

      // 底部顏色比頂部稍微領先，形成向下流動的效果
      const topProgress = baseProgress;
      const bottomProgress = (baseProgress + config.gradientBottomOffset) % 1;

      // 獲取顏色（簡化版本：直接在兩個主要顏色之間插值）
      function getColorAtProgress(progress: number): { r: number; g: number; b: number } {
        // 將進度映射到顏色陣列索引（不包含最後一個重複的顏色）
        const effectiveLength = gradientColors.length - 1;
        const colorIndex = progress * effectiveLength;
        const indexFloor = Math.floor(colorIndex);
        const indexCeil = Math.min(indexFloor + 1, effectiveLength);
        const t = colorIndex - indexFloor;

        const color1 = gradientColors[indexFloor];
        const color2 = gradientColors[indexCeil];

        return {
          r: Math.round(lerp(color1.r, color2.r, t)),
          g: Math.round(lerp(color1.g, color2.g, t)),
          b: Math.round(lerp(color1.b, color2.b, t)),
        };
      }

      const topColor = getColorAtProgress(topProgress);
      const bottomColor = getColorAtProgress(bottomProgress);

      return {
        top: rgbToHex(topColor.r, topColor.g, topColor.b),
        bottom: rgbToHex(bottomColor.r, bottomColor.g, bottomColor.b),
      };
    }

    // 更新背景漸層
    function updateBackgroundGradient(time: number) {
      const colors = getGradientColors(time);
      container.style.background = `linear-gradient(to bottom, ${colors.top} 0%, ${colors.bottom} 100%)`;
    }

    // 檢查容器是否存在
    if (!container) return;

    // 創建場景
    const scene = new THREE.Scene();

    // 創建正射影相機（增大 viewSize 讓左右兩邊也能看到平面）
    const width = container.offsetWidth;
    const height = container.offsetHeight;
    const aspect = width / height;
    const viewSize = 800; // 增大視圖大小以覆蓋更廣的範圍
    const camera = new THREE.OrthographicCamera(-viewSize * aspect, viewSize * aspect, viewSize, -viewSize, 0.1, 2000);
    camera.position.z = 1000;

    // 創建平面系統（類似白紙）- 根據裝置性能調整數量
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    const boxCount = isMobile ? 100 : 150; // 從 200 減少到 150/100

    // 創建渲染器 - 優化性能設定
    const renderer = new THREE.WebGLRenderer({
      alpha: true,
      antialias: !isMobile, // 移動裝置關閉抗鋸齒
      powerPreference: 'low-power', // 偏好低功耗模式
    });
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    // 限制像素比率以提升性能
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    const boxes: THREE.Mesh[] = [];
    const boxVelocities: Array<{ x: number; y: number; z: number }> = [];
    const boxRotations: Array<{ x: number; y: number; z: number }> = [];

    // 平面顏色（以 0xf0f8ff 為基準，類似白紙的顏色）
    // 基準顏色 RGB(240, 248, 255)
    const paperColors = [
      0xf5faff, // 稍微亮一點 RGB(245, 250, 255) +5
      0xf0f8ff, // 基準 RGB(240, 248, 255)
      0xebf3f8, // 稍微暗一點 RGB(235, 243, 248) -5
      0xe6eef5, // 更暗一點 RGB(230, 238, 245) -10
    ];

    // 初始化平面
    for (let i = 0; i < boxCount; i++) {
      // 隨機大小（長方形平面，類似紙張的比例）
      const width = Math.random() * 80 + 40; // 寬度 40-80
      const height = Math.random() * 60 + 30; // 高度 30-60（稍微窄一點，更像紙張）

      // 創建平面幾何體
      const geometry = new THREE.PlaneGeometry(width, height);

      // 隨機選擇一個顏色
      const randomColor = paperColors[Math.floor(Math.random() * paperColors.length)];

      // 設置材質（使用 MeshBasicMaterial 不需要燈光）
      const material = new THREE.MeshBasicMaterial({
        color: randomColor,
        transparent: true,
        opacity: 0.7, // 降低透明度讓光線可以透過
        side: THREE.DoubleSide, // 雙面渲染
      });

      const box = new THREE.Mesh(geometry, material);

      // 隨機位置（根據相機視角範圍來設定平面分布，確保覆蓋整個可見區域）
      // 計算相機的可見範圍，並讓平面分布在更廣的範圍內
      const xRange = viewSize * aspect * 1.5; // 比相機可見範圍大 2 倍，確保左右兩邊都有方塊
      const yRange = viewSize * 1.5; // 比相機可見範圍大 2 倍
      box.position.x = (Math.random() - 0.5) * xRange * 1.5; // x 軸範圍：-xRange 到 xRange
      box.position.y = (Math.random() - 0.5) * yRange * 1.5; // y 軸範圍：-yRange 到 yRange
      box.position.z = (Math.random() - 0.5) * 2000; // 增加深度範圍

      // 隨機初始旋轉
      box.rotation.x = Math.random() * Math.PI * 2;
      box.rotation.y = Math.random() * Math.PI * 2;
      box.rotation.z = Math.random() * Math.PI * 2;

      // 速度設定：所有平面都向下移動（y 軸負方向），x 和 z 軸保留一些隨機性
      boxVelocities.push({
        x: (Math.random() - 0.5) * config.boxHorizontalSpeed * 2, // x 軸隨機移動
        y: -(Math.random() * (config.boxFallSpeed.max - config.boxFallSpeed.min) + config.boxFallSpeed.min), // y 軸向下移動
        z: (Math.random() - 0.5) * config.boxHorizontalSpeed * 2, // z 軸隨機移動
      });

      // 隨機旋轉速度
      boxRotations.push({
        x: (Math.random() - 0.5) * config.boxRotationSpeed * 2,
        y: (Math.random() - 0.5) * config.boxRotationSpeed * 2,
        z: (Math.random() - 0.5) * config.boxRotationSpeed * 2,
      });

      boxes.push(box);
      scene.add(box);
    }

    // 動畫循環
    function animate() {
      animationId = requestAnimationFrame(animate);

      // 更新背景漸層（與方塊動畫同步）
      updateBackgroundGradient(Date.now());

      // 更新每個平面的位置和旋轉
      // 計算當前的邊界範圍
      const currentAspect = container.offsetWidth / container.offsetHeight;
      const currentXRange = viewSize * currentAspect * 1.5;
      const currentYRange = viewSize * 1.5;

      for (let i = 0; i < boxCount; i++) {
        const box = boxes[i];
        const velocity = boxVelocities[i];
        const rotation = boxRotations[i];

        // 更新位置
        box.position.x += velocity.x;
        box.position.y += velocity.y;
        box.position.z += velocity.z;

        // 更新旋轉
        box.rotation.x += rotation.x;
        box.rotation.y += rotation.y;
        box.rotation.z += rotation.z;

        // 邊界檢測：只檢測向下移動，超出底部時從頂部重新出現
        // 提前檢測並重新生成，縮小間隔
        if (box.position.y < -currentYRange * 0.9) {
          // 重新生成到稍微低一點的位置，縮小間隔
          box.position.y = currentYRange * 0.9; // 從頂部稍微低一點的位置重新出現
          box.position.x = (Math.random() - 0.5) * currentXRange * 1.5; // 重新隨機 x 位置
          box.position.z = (Math.random() - 0.5) * 2000; // 重新隨機 z 位置
          // 重新隨機旋轉
          box.rotation.x = Math.random() * Math.PI * 2;
          box.rotation.y = Math.random() * Math.PI * 2;
          box.rotation.z = Math.random() * Math.PI * 2;
        }
      }

      // 相機固定在畫布中央
      camera.position.set(0, 0, 1000);
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }

    // 處理視窗大小變化
    function handleResize() {
      const width = container.offsetWidth;
      const height = container.offsetHeight;
      const aspect = width / height;

      // 更新正射影相機的視圖大小
      camera.left = -viewSize * aspect;
      camera.right = viewSize * aspect;
      camera.top = viewSize;
      camera.bottom = -viewSize;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
    }

    window.addEventListener('resize', handleResize);

    // 聲明 animationId 變數
    let animationId: number;

    // 開始動畫
    animate();

    // 清理函數
    const cleanup = () => {
      window.removeEventListener('resize', handleResize);
      renderer.dispose();
      boxes.forEach((box) => {
        box.geometry.dispose();
        if (Array.isArray(box.material)) {
          box.material.forEach((mat: THREE.Material) => mat.dispose());
        } else {
          (box.material as THREE.Material).dispose();
        }
      });
    };

    window.addEventListener('beforeunload', cleanup);

    // 當頁面不可見時暫停動畫以節省資源
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        cancelAnimationFrame(animationId);
      } else {
        animate();
      }
    });
  }

  // 使用 IntersectionObserver 來延遲初始化
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          // 元件進入視窗後延遲 100ms 初始化,避免阻塞渲染
          setTimeout(() => initStarfield(), 100);
          observer.disconnect();
        }
      });
    },
    { threshold: 0.1 },
  );

  if (container) {
    observer.observe(container);
  }
</script>
